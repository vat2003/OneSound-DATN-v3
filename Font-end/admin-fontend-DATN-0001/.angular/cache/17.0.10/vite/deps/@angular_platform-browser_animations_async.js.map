{
  "version": 3,
  "sources": ["../../../../../node_modules/@angular/platform-browser/fesm2022/animations/async.mjs"],
  "sourcesContent": ["/**\r\n * @license Angular v17.0.9\r\n * (c) 2010-2022 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\r\n\r\nimport { DOCUMENT } from '@angular/common';\r\nimport { ɵRuntimeError, makeEnvironmentProviders, RendererFactory2, NgZone, ANIMATION_MODULE_TYPE } from '@angular/core';\r\nimport { ɵDomRendererFactory2 } from '@angular/platform-browser';\r\n\r\nconst ANIMATION_PREFIX = '@';\r\nclass AsyncAnimationRendererFactory {\r\n    /**\r\n     *\r\n     * @param moduleImpl allows to provide a mock implmentation (or will load the animation module)\r\n     */\r\n    constructor(doc, delegate, zone, animationType, moduleImpl) {\r\n        this.doc = doc;\r\n        this.delegate = delegate;\r\n        this.zone = zone;\r\n        this.animationType = animationType;\r\n        this.moduleImpl = moduleImpl;\r\n        this._rendererFactoryPromise = null;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    loadImpl() {\r\n        const moduleImpl = this.moduleImpl ?? import('@angular/animations/browser');\r\n        return moduleImpl\r\n            .catch((e) => {\r\n            throw new ɵRuntimeError(5300 /* RuntimeErrorCode.ANIMATION_RENDERER_ASYNC_LOADING_FAILURE */, (typeof ngDevMode === 'undefined' || ngDevMode) &&\r\n                'Async loading for animations package was ' +\r\n                    'enabled, but loading failed. Angular falls back to using regular rendering. ' +\r\n                    'No animations will be displayed and their styles won\\'t be applied.');\r\n        })\r\n            .then(({ ɵcreateEngine, ɵAnimationRendererFactory }) => {\r\n            // We can't create the renderer yet because we might need the hostElement and the type\r\n            // Both are provided in createRenderer().\r\n            const engine = ɵcreateEngine(this.animationType, this.doc);\r\n            const rendererFactory = new ɵAnimationRendererFactory(this.delegate, engine, this.zone);\r\n            this.delegate = rendererFactory;\r\n            return rendererFactory;\r\n        });\r\n    }\r\n    /**\r\n     * This method is delegating the renderer creation to the factories.\r\n     * It uses default factory while the animation factory isn't loaded\r\n     * and will rely on the animation factory once it is loaded.\r\n     *\r\n     * Calling this method will trigger as side effect the loading of the animation module\r\n     * if the renderered component uses animations.\r\n     */\r\n    createRenderer(hostElement, rendererType) {\r\n        const renderer = this.delegate.createRenderer(hostElement, rendererType);\r\n        if (renderer.ɵtype === 0 /* AnimationRendererType.Regular */) {\r\n            // The factory is already loaded, this is an animation renderer\r\n            return renderer;\r\n        }\r\n        // We need to prevent the DomRenderer to throw an error because of synthetic properties\r\n        if (typeof renderer.throwOnSyntheticProps === 'boolean') {\r\n            renderer.throwOnSyntheticProps = false;\r\n        }\r\n        // Using a dynamic renderer to switch the renderer implementation once the module is loaded.\r\n        const dynamicRenderer = new DynamicDelegationRenderer(renderer);\r\n        // Kick off the module loading if the component uses animations but the module hasn't been\r\n        // loaded yet.\r\n        if (rendererType?.data?.['animation'] && !this._rendererFactoryPromise) {\r\n            this._rendererFactoryPromise = this.loadImpl();\r\n        }\r\n        this._rendererFactoryPromise\r\n            ?.then((animationRendererFactory) => {\r\n            const animationRenderer = animationRendererFactory.createRenderer(hostElement, rendererType);\r\n            dynamicRenderer.use(animationRenderer);\r\n        })\r\n            .catch(e => {\r\n            // Permanently use regular renderer when loading fails.\r\n            dynamicRenderer.use(renderer);\r\n        });\r\n        return dynamicRenderer;\r\n    }\r\n    begin() {\r\n        this.delegate.begin?.();\r\n    }\r\n    end() {\r\n        this.delegate.end?.();\r\n    }\r\n    whenRenderingDone() {\r\n        return this.delegate.whenRenderingDone?.() ?? Promise.resolve();\r\n    }\r\n}\r\n/**\r\n * The class allows to dynamicly switch between different renderer implementations\r\n * by changing the delegate renderer.\r\n */\r\nclass DynamicDelegationRenderer {\r\n    constructor(delegate) {\r\n        this.delegate = delegate;\r\n        // List of callbacks that need to be replayed on the animation renderer once its loaded\r\n        this.replay = [];\r\n        this.ɵtype = 1 /* AnimationRendererType.Delegated */;\r\n    }\r\n    use(impl) {\r\n        this.delegate = impl;\r\n        if (this.replay !== null) {\r\n            // Replay queued actions using the animation renderer to apply\r\n            // all events and properties collected while loading was in progress.\r\n            for (const fn of this.replay) {\r\n                fn(impl);\r\n            }\r\n            // Set to `null` to indicate that the queue was processed\r\n            // and we no longer need to collect events and properties.\r\n            this.replay = null;\r\n        }\r\n    }\r\n    get data() {\r\n        return this.delegate.data;\r\n    }\r\n    destroy() {\r\n        this.replay = null;\r\n        this.delegate.destroy();\r\n    }\r\n    createElement(name, namespace) {\r\n        return this.delegate.createElement(name, namespace);\r\n    }\r\n    createComment(value) {\r\n        return this.delegate.createComment(value);\r\n    }\r\n    createText(value) {\r\n        return this.delegate.createText(value);\r\n    }\r\n    get destroyNode() {\r\n        return this.delegate.destroyNode;\r\n    }\r\n    appendChild(parent, newChild) {\r\n        this.delegate.appendChild(parent, newChild);\r\n    }\r\n    insertBefore(parent, newChild, refChild, isMove) {\r\n        this.delegate.insertBefore(parent, newChild, refChild, isMove);\r\n    }\r\n    removeChild(parent, oldChild, isHostElement) {\r\n        this.delegate.removeChild(parent, oldChild, isHostElement);\r\n    }\r\n    selectRootElement(selectorOrNode, preserveContent) {\r\n        return this.delegate.selectRootElement(selectorOrNode, preserveContent);\r\n    }\r\n    parentNode(node) {\r\n        return this.delegate.parentNode(node);\r\n    }\r\n    nextSibling(node) {\r\n        return this.delegate.nextSibling(node);\r\n    }\r\n    setAttribute(el, name, value, namespace) {\r\n        this.delegate.setAttribute(el, name, value, namespace);\r\n    }\r\n    removeAttribute(el, name, namespace) {\r\n        this.delegate.removeAttribute(el, name, namespace);\r\n    }\r\n    addClass(el, name) {\r\n        this.delegate.addClass(el, name);\r\n    }\r\n    removeClass(el, name) {\r\n        this.delegate.removeClass(el, name);\r\n    }\r\n    setStyle(el, style, value, flags) {\r\n        this.delegate.setStyle(el, style, value, flags);\r\n    }\r\n    removeStyle(el, style, flags) {\r\n        this.delegate.removeStyle(el, style, flags);\r\n    }\r\n    setProperty(el, name, value) {\r\n        // We need to keep track of animation properties set on default renderer\r\n        // So we can also set them also on the animation renderer\r\n        if (this.shouldReplay(name)) {\r\n            this.replay.push((renderer) => renderer.setProperty(el, name, value));\r\n        }\r\n        this.delegate.setProperty(el, name, value);\r\n    }\r\n    setValue(node, value) {\r\n        this.delegate.setValue(node, value);\r\n    }\r\n    listen(target, eventName, callback) {\r\n        // We need to keep track of animation events registred by the default renderer\r\n        // So we can also register them against the animation renderer\r\n        if (this.shouldReplay(eventName)) {\r\n            this.replay.push((renderer) => renderer.listen(target, eventName, callback));\r\n        }\r\n        return this.delegate.listen(target, eventName, callback);\r\n    }\r\n    shouldReplay(propOrEventName) {\r\n        //`null` indicates that we no longer need to collect events and properties\r\n        return this.replay !== null && propOrEventName.startsWith(ANIMATION_PREFIX);\r\n    }\r\n}\r\n\r\n/**\r\n * Returns the set of [dependency-injection providers](guide/glossary#provider)\r\n * to enable animations in an application. See [animations guide](guide/animations)\r\n * to learn more about animations in Angular.\r\n *\r\n * When you use this function instead of the eager `provideAnimations()`, animations won't be\r\n * renderered until the renderer is loaded.\r\n *\r\n * @usageNotes\r\n *\r\n * The function is useful when you want to enable animations in an application\r\n * bootstrapped using the `bootstrapApplication` function. In this scenario there\r\n * is no need to import the `BrowserAnimationsModule` NgModule at all, just add\r\n * providers returned by this function to the `providers` list as show below.\r\n *\r\n * ```typescript\r\n * bootstrapApplication(RootComponent, {\r\n *   providers: [\r\n *     provideAnimationsAsync()\r\n *   ]\r\n * });\r\n * ```\r\n *\r\n * @param type pass `'noop'` as argument to disable animations.\r\n *\r\n * @publicApi\r\n * @developerPreview\r\n */\r\nfunction provideAnimationsAsync(type = 'animations') {\r\n    return makeEnvironmentProviders([\r\n        {\r\n            provide: RendererFactory2,\r\n            useFactory: (doc, renderer, zone) => {\r\n                return new AsyncAnimationRendererFactory(doc, renderer, zone, type);\r\n            },\r\n            deps: [DOCUMENT, ɵDomRendererFactory2, NgZone],\r\n        },\r\n        {\r\n            provide: ANIMATION_MODULE_TYPE,\r\n            useValue: type === 'noop' ? 'NoopAnimations' : 'BrowserAnimations',\r\n        },\r\n    ]);\r\n}\r\n\r\n/**\r\n * @module\r\n * @description\r\n * Entry point for all animation APIs of the animation browser package.\r\n */\r\n\r\n/**\r\n * @module\r\n * @description\r\n * Entry point for all public APIs of this package.\r\n */\r\n\r\n// This file is not used to build this module. It is only used during editing\r\n\r\n/**\r\n * Generated bundle index. Do not edit.\r\n */\r\n\r\nexport { provideAnimationsAsync, AsyncAnimationRendererFactory as ɵAsyncAnimationRendererFactory };\r\n\r\n"],
  "mappings": "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",
  "names": []
}
